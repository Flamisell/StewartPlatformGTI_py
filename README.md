# Optimal design of a Stewart platform using the global transmission index under determinate constraint of workspace

---

This repository is the application of the Research article
first published online October 23, 2017 :

"*Optimal design of a Stewart platform using the global transmission index under determinate constraint of workspace* "
(https://doi.org/10.1177/168781401772088) (https://journals.sagepub.com/doi/10.1177/1687814017720880)


You can use this repository to find the optimal set of parameters which define a Stewart Platform (base_radius,base_angle,platform_radius,platform_angles) based on the maximization of the Global Transmission Index. In this article, screw theory is used to find the transmissability indexes: "*The transmissibility indexes describe the transmission ability from the joint force to the platform movement.*"

The big advantage of this paper is the possibility to optimise the joint configuration of the parallel manipulator based on frame-free and unit homogeneous indexes.


- Due to ne natural frame-dependence of the Jacobian, each index coming from it will be directly dependent on the position in space of the platform : "*Thus, those evaluation indexes share common drawbacks such as frame-dependent property and the unit inhomogeneous problem*". Because the Transmission Index is based on power transmission, which is a scalar, we can solve such drawbacks: "*Thus, this kind of evaluation indexes is frame-free and unit homogeneous.*"


---
This repository focuses on replicating the analysis presented in the referenced paper.  
First, a brief explanation of screw theory, which serves as the foundation for this paper, is provided. Then, the explained step-by-step procedure outlined in the paper is carefully implemented.

## Table of Contents

- [Explanation of Screw Theory and Global Transmission Index](#explanation-of-screw-theory-and-global-transmission-index) 
- [Usage](#usage)
  - [Singularity Search](#singularity-search)
    - [Platform Initialization](#platform-initialization)
    - [Find Singularities](find-singularities)
    - [Filter Singularities](filter-singularities)
  - [Closest Singularity Search and Visualization](#closest-singularity-search-and-visualization)
- [Class Methods Overview](#class-methods-overview)

## Explanation of Screw Theory and Global Transmission Index
Super quick review of Screw Theory.

A screw can be used to describe the movement of a rigid body, usually called twist screw, and also can be used to describe the generalized force applied on a rigid body named wrench screw.

The physical significance of the reciprocal product is the instantaneous power generated by the wrench screw on the rigid body which is moving under the motion described by the twist screw . The reciprocal product between the twist screw St and the wrench screw Sw is the instantaneous power generated by the two screws.

<img src="https://github.com/user-attachments/assets/d453e48e-d585-47a6-b435-a3df827c7b79" width="600" />

The instantaneous power can be defined as:

<img src="https://github.com/user-attachments/assets/49288b5e-36e2-4362-a4f4-41bbe0d49b9b" width="400" />

For most mechanisms, the prime function is to transmit motion from the input joint to the output joint and the end effector, so the motion of the output joint and the end effector caused by the movement of the input joint represented in screw format is called the output twist screw (OTS). Similarly, the external load exerted on the output joint and the end effector is transmitted to the input joint, so the internal wrench caused by the external load represented in screw format is called the transmission wrench screw (TWS).

<img src="https://github.com/user-attachments/assets/9d41ced8-2214-4a2d-bc13-04e7864a7b98" width="400" />

The definition of TI (transmission index) for spatial mechanisms is the ratio of instantaneous power and the maximum power generated by the unit TWS (Transmission Wrench Screw Sw) and OTS (Output Twist Screw St) on a rigid body. Hence, the TI between TWS and OTS can be represented as

<img src="https://github.com/user-attachments/assets/f12e8bf9-544f-4c7e-8793-a0e2f0056da9" width="350" />

We can then integrate the transmission index TI , in the whole workspace to obtain a Global Transmission Index relative to the platform joint configuration [r_b, r_p , phi_p , phi_b]. We can then vary the joint configuration to find the configuration which maximises the Global Transmission Index.

<img src="https://github.com/user-attachments/assets/52922e48-77cf-406b-afbc-8c16aec35cf1" width="450" />


## Installation

Ensure you have the required libraries:

```bash
import numpy as np
from scipy.spatial.transform import Rotation as R
import matplotlib.pyplot as plt
from google.colab import drive
from scipy.spatial.distance import cdist

```

## Usage

### Singularity Search
The steps to obtain an offline set of singular configurations is presented here below.

#### Platform Initialization
This class has multiple purposes which will not be discussed here but can be found in my Stewart Platform Class repository, the key function that is used in this notebook is the *getSingularityWorkspace* function.
By defining the workspace boundaries (in terms of position and orientation), the local condition index of the transposed Jacobian matrix is calculated for each pose telling us when Jabobian becomes singular.

To create an instance of the StewartPlatform class, you need to provide the following parameters:
- r_b: Radius of the base.
- phi_b: Angle between base joints.
- r_p: Radius of the platform.
- phi_p: Angle between platform joints.

It is also important to define limits on workspace position and orientation, this limits will define the boundaries of the search.
```
# Define parameters
r_b = 0.5  # Radius of base
phi_b = 50  # Angle between base joints
r_p = 0.3  # Radius of platform
phi_p = 80  # Angle between platform joints

# Create Stewart Platform instance
platform = StewartPlatform(r_b, phi_b, r_p, phi_p) # Initialize platform
pose=np.array([0,0,0.5,10,0,0]) # Define pose
lengths= platform.getIK(pose) # Find Joint position
k=platform.getLocalConditionIndexT() # Tells you how close you are to a singularity

# Define workspace and orientation limints
workspace_limits = [-0.5, 0.5, -0.5, 0.5, 0.1, 0.6]
orientation_limits = [-10, 10, -10, 10, -10, 10]
x_min, x_max, y_min, y_max, z_min, z_max = workspace_limits
roll_min, roll_max, pitch_min, pitch_max, yaw_min, yaw_max = orientation_limits
```
Mount the drive
```
from google.colab import drive
drive.mount('/content/drive')
```
#### Find Singularities
Use *getSingularityWorkspace* to search for any pose which has a low local condition index. Note: this can be computationally expensive.
```
N_pos=10 # Discretization for workspace coordinates
N_orient=10 # Discretization for orientation coordinates
Holder=platform.getSingularityWorkspace(workspace_limits,orientation_limits,N_pos,N_orient) # find singularities in all space
```
Save the singularities onto drive for safety.
```
 with open('/content/drive/My Drive/Github/singularities_2.txt', 'w') as f:
     np.savetxt(f, Holder)
```
Load the whole singularity file.
```
with open('/content/drive/My Drive/Github/singularities_2.txt', 'r') as f:
    singularities = np.loadtxt(f)
```
#### Filter Singularities
*First Filtering*

Slicing the matrix, removing the borders of the workspace (external singularities) and selecting only the poses with low local condition index.
```
keep_mask = (singularities[:, 6] < 0.001) & (singularities[:, 2] > z_min)& (singularities[:, 2] < z_max) & (singularities[:, 0] < x_max)& (singularities[:, 0] > x_min)& (singularities[:, 1] < y_max) & (singularities[:, 1] > y_min)
interest_points_with_index=singularities[keep_mask]
```
*Second filtering*

We normalize the singularities between the borders of the workspace, we then calculate the distance matrix between all of them and remove the configurations which are too close to each other.

```
from scipy.spatial.distance import cdist

# take only poses
interest_points=interest_points_with_index[:,:6]
#normalize the singularities poses
mins=np.array([x_min,y_min,z_min,roll_min,pitch_min,yaw_min])
maxs=np.array([x_max,y_max,z_max,roll_max,pitch_max,yaw_max])
normalized_interest_points = (interest_points - mins) / (maxs - mins)

threshold=0.3
distances = cdist(normalized_interest_points, normalized_interest_points)
# To avoid self-comparison, set the diagonal to a large value
np.fill_diagonal(distances, np.inf)

index_holder=[]
interest_points_holder=np.copy(interest_points_with_index)
keep_mask = np.ones(normalized_interest_points.shape[0], dtype=bool)
for i in range(normalized_interest_points.shape[0]):
    interest_points_holder[i][6]=i
    if keep_mask[i]:
        # Find indices of vectors within the threshold distance
        close_indices = np.where(distances[i] < threshold)[0]
        # Set keep_mask to False for these indices
        keep_mask[close_indices] = False
        # Ensure we don't set the current vector's mask to False
        keep_mask[i] = True


interest_points_filtered=interest_points_holder[keep_mask] # kept singularities
interest_points_deleted=interest_points_holder[~keep_mask] # removed singularities
```
Save singularities in task space and in joint space.
```
# Save the filtered singularities as task singularities
singularities_task_space=np.copy(interest_points_filtered[:,:6])
with open('/content/drive/My Drive/Github/filtered_singularities_task_space_2.txt', 'w') as f:
    np.savetxt(f, singularities_task_space)

# Save the filtered singularities as joint singularities
singularities_joint_space=np.copy(interest_points_filtered[:,:6])
for i in range(len(singularities_task_space)):
  singularities_joint_space[i,:]=np.linalg.norm(platform.getIK(singularities_task_space[i,:]),axis=1)
with open('/content/drive/My Drive/Github/filtered_singularities_joint_space_2.txt', 'w') as f:
    np.savetxt(f, singularities_joint_space)
```
### Closest Singularity Search and Visualization
In this section is shown how to search for the closest singularity given a configuration of the platform and how to visualize the singularity space in both position and orientation space. Note: stewart platform's singularities live in R6, to visualize them we need to fix either position or orientation of the platform.

Load singularities from the drive
```
with open('/content/drive/My Drive/Github/filtered_singularities_task_space_2.txt', 'r') as f:
    singularities_task_space = np.loadtxt(f)

with open('/content/drive/My Drive/Github/filtered_singularities_joint_space_2.txt', 'r') as f:
    singularities_joint_space = np.loadtxt(f)
```
Find the closest singularity to defined position.

Check local condition index and the actuator forces in pose and singularity.
```
# find the closest singularity.
pose=np.array([0,0.35,0.2,0,0,0])
mins=np.array([x_min,y_min,z_min,roll_min,pitch_min,yaw_min])
maxs=np.array([x_max,y_max,z_max,roll_max,pitch_max,yaw_max])
mins = np.array(mins)
maxs = np.array(maxs)

# Normalize each component
normalized_pose = (pose - mins) / (maxs - mins)
# print(normalized_pose)
normalized_singularities=(singularities_task_space-mins)/(maxs-mins)
# print(normalized_singularities)
distances = np.linalg.norm(normalized_singularities - normalized_pose, axis=1)
# print(distances)
# # Find the index of the minimum distance
min_index = np.argmin(distances)
# print(distances[min_index])

# # Return the closest vector
closest_vector = singularities_task_space[min_index]


k=platform.getLocalConditionIndexT()
lengths=platform.getIK(pose)
k=platform.getLocalConditionIndexT()
Fg=np.array([-10,0,0,0,0,0])

joint_forces=platform.getActuatorForces(Fg)
platform.plot()
print("pose :", pose)
print("local condition number T :", k)
print("joint_forces :", joint_forces)


lengths=platform.getIK(closest_vector)
platform.plot()
k=platform.getLocalConditionIndexT()
joint_forces=platform.getActuatorForces(Fg)
print("closest singularity :", closest_vector)
print("local condition number T :", k)
print("joint_forces :", joint_forces)
```
<img src="https://github.com/Flamisell/StewartPlatformSingularities_py/blob/main/img/stewart1.png" width="400"> <img src="https://github.com/Flamisell/StewartPlatformSingularities_py/blob/main/img/Stewart22.png" width="450">


It is possible to plot 3d the singularity planes as long as we fix either position or orientation.
We can use plotly libraries to clearly see the planes. I will leave the code directly in the colab file.
```
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
```
**Fixing Position**
```
# Choose a position
position = np.array([-0.45,0.1,0.2])

N=10 # discretization of space
choice=6 # choose choice 6 for local condition index
orientation_limits = [-10, 10, -10, 10, -10, 10] # use same orientation limits as singularity search
roll_min, roll_max, pitch_min, pitch_max, yaw_min, yaw_max = orientation_limits

# use the getIndexWorkspaceOrientation function to see how the local condition index changes when orienting the platform
workspace_indices_orientation = platform.getIndexWorkspaceOrientation(position, orientation_limits, N, choice)
```
<img src="https://github.com/Flamisell/StewartPlatformSingularities_py/blob/main/img/FixingPos.png" width="400">

**Fixing Orientation**
```
# Choose an orientation
orientation = np.array([8,7,5]) # RPY
N=10 # discretization of space
choice=6 # choose choice 6 for local condition index
workspace_limits = [-0.5, 0.5, -0.5, 0.5, 0.1, 0.6] # use same workspace limits as singularity search
x_min, x_max, y_min, y_max, z_min, z_max = workspace_limits

# use the getIndexWorkspacePosition function to see how the local condition index changes when positioning the platform
workspace_indices_position = platform.getIndexWorkspacePosition(orientation, workspace_limits, N, choice)
```
<img src="https://github.com/Flamisell/StewartPlatformSingularities_py/blob/main/img/FixingOr.png" width="400">

## Class Methods Overview
- **getIK(pose):** Computes inverse kinematics.
- **getFK(starting_pose, lengths_desired):** Computes forward kinematics.
- **getLocalConditionIndexT():** Calculates the local condition index of Transposed Jacobian
- **getPlatformForces(F_actuators):** Computes platform forces from actuator forces.
- **getSingularityWorkspace(workspace_limits,orientation_limits,N_pos,N_orient):** Evaluate singularities over a range of positions in the workspace.
- **plot():** Plots the Stewart platform configuration.
